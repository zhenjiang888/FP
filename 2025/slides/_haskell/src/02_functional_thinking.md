# ç¬¬ 02 ç« ï¼šåˆè§å‡½æ•°å¼æ€ç»´

### 01 ä¸¤å¥å¾ˆæœ‰å“²ç†çš„è¯

- å·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨ã€‚

- To a man with a hammer, everything looks like a nail.

> - æ€ç»´æ–¹å¼æ˜¯ä¸€ç§å·¥å…·ï¼›ä¸èƒ½è¢«æ€ç»´æ–¹å¼æŸç¼š

### 02 â€œå‡½æ•°å¼æ€ç»´â€ æ˜¯ä¸€ç§ä»€ä¹ˆæ ·çš„æ€ç»´æ–¹å¼

- ä½¿ç”¨ â€œæ•°å­¦ä¸­çš„å‡½æ•°â€ ä½œä¸º æ±‚è§£ä¿¡æ¯å¤„ç†é—®é¢˜çš„åŸºæœ¬æˆåˆ†ã€‚

- â€œä½¿ç”¨æ–¹å¼â€ åŒ…æ‹¬ï¼š

  - ä»é›¶å¼€å§‹ï¼Œå®šä¹‰ä¸€äº›åŸºæœ¬å‡½æ•°

  - æŠŠå·²æœ‰çš„å‡½æ•°ç»„è£…èµ·æ¥ï¼Œå½¢æˆæ–°çš„å‡½æ•°

### 03 ç®€è¦å›é¡¾ï¼šæ•°å­¦ä¸­çš„å‡½æ•°

> **å®šä¹‰ï¼š** å‡½æ•° / Function
>
> å¯¹ä»»ä½•ä¸¤ä¸ªé›†åˆ`X`å’Œ`Y`ï¼Œç§°ä¸¤è€…ä¹‹é—´çš„å…³ç³»`f âŠ† X âœ— Y`æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå½“ä¸”ä»…å½“å¦‚ä¸‹æ¡ä»¶æˆç«‹ï¼š
>
> - `âˆ€ x âˆˆ X, âˆƒ (u, v) âˆˆ f, x = u`
> - `âˆ€ (x, y) âˆˆ f, âˆ€ (u, v) âˆˆ f, x = u => y == v`
>
> > ä¹Ÿå³ï¼šå¯¹`X`ä¸­çš„ä»»ä½•å…ƒç´ `x`ï¼Œå­˜åœ¨ä¸”ä»…å­˜å”¯ä¸€ä¸€ä¸ªå…ƒç´ `y âˆˆ Y`ï¼Œæ»¡è¶³`(x, y) âˆˆ f`

#### å‡½æ•°ç›¸å…³çš„è¡¨ç¤ºç¬¦å·ï¼š

å¯¹ä»»ä½•ä¸¤ä¸ªé›†åˆ`X`å’Œ`Y`ï¼Œ

- `X âœ— Y`
  - ä¸€ä¸ªé›†åˆï¼Œå…¶å®šä¹‰ä¸ºï¼š`{ (x, y) | x âˆˆ X, y âˆˆ Y }`

  - ä¹Ÿç§°ä¸ºé›†åˆ `X` å’Œ `Y` çš„ **ç¬›å¡å°”ç§¯**

- `X -> Y`
  - ä¸€ä¸ªé›†åˆï¼ŒåŒ…å«ä¸”ä»…åŒ…å«æ‰€æœ‰ä»`X`åˆ°`Y`çš„å‡½æ•°

- `f : X -> Y`
  - å£°æ˜`f`æ˜¯ä¸€ä¸ªä»`X`åˆ°`Y`çš„å‡½æ•°ã€‚ä¹Ÿç§°ï¼š`f`æ˜¯ä¸€ä¸ªç±»å‹ä¸º`X -> Y`çš„å‡½æ•°

  - ç§°ï¼š`X`ä¸º`f`çš„**å®šä¹‰åŸŸ** (Domain)ï¼›`Y`ä¸º`f`çš„**å€¼åŸŸ** (Codomain)

- `f(x)`

  - å‡½æ•°`f`çš„å®šä¹‰åŸŸä¸­å…ƒç´ `x`æ˜ å°„åˆ°çš„å€¼åŸŸä¸­çš„é‚£ä¸ªå…ƒç´ ï¼Œ

  - æ˜¾ç„¶å¯çŸ¥ï¼š
    - `f(x) : Y`ï¼Œä¹Ÿå³ï¼š`f(x)`çš„ç±»å‹ä¸º`Y`

    - `(x, f(x)) âˆˆ f`

#### å¸¸ç”¨çš„é›†åˆåŠå…¶è¡¨ç¤ºç¬¦å·ï¼š

> åœ¨ Haskell ä¸­ï¼Œâ€œç±»å‹â€ å’Œ â€œé›†åˆâ€ æ˜¯åŒä¹‰è¯

- `â„•`ï¼šè‡ªç„¶æ•°é›†åˆ/ç±»å‹

- `â„¤`ï¼šæ•´æ•°é›†åˆ/ç±»å‹

- `â„š`ï¼šæœ‰ç†æ•°é›†åˆ/ç±»å‹

- `â„`ï¼šå®æ•°é›†åˆ/ç±»å‹

- `ğ”¹ = { true, flse }`ï¼šå¸ƒå°”é›†åˆ/ç±»å‹ã€‚å…¶ä¸­ï¼Œ

  - `true` è¡¨ç¤º â€œçœŸâ€ï¼›`flse` è¡¨ç¤º â€œå‡â€

  - ç¨åç»™å‡º `ğ”¹` çš„ä¸€ç§æ›´ä¸ºå½¢å¼åŒ–çš„å®šä¹‰

> **å®šä¹‰ï¼š** å‡½æ•°çš„ç»„åˆ / Function Composition
>
> å¯¹ä»»ä½•ä¸¤ä¸ªå‡½æ•° `f : X -> Y`ã€`g : Y -> Z`ï¼Œä¸¤è€…çš„ç»„åˆï¼Œè®°ä¸º `g * f`ï¼Œæ˜¯ä¸€ä¸ªå‡½æ•°ã€‚
>
> è¯¥å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š
>
> ```haskell
> [ X Y Z : Set, f : X -> Y, g : Y -> Z ]
> def g * f : X -> Z = [x : X] g(f(x))
> ```
> è¯´æ˜ï¼š
>
> - ä¸Šè¿°å®šä¹‰ä¸æ˜¯é‡‡ç”¨ Haskell è¯­è¨€ä¹¦å†™çš„ç¨‹åº
>
> - æœ¬ç« ä¸­å‡ºç°çš„æ‰€æœ‰ç¨‹åº (é™¤äº†æœ€åä¸€ä¸ª)ï¼Œéƒ½ä¸æ˜¯ Haskell ç¨‹åº
>   - è¿™äº›ç¨‹åºæ‰€é‡‡ç”¨çš„è¯­æ³•ï¼Œæ¥æºäºæˆ‘ä»¬æ­£åœ¨è®¾è®¡ä¸­çš„ä¸€ç§ç”¨äºæ•°å­¦è¯æ˜çš„è¯­è¨€

### 04 ä¸ºä»€ä¹ˆåœ¨å‡½æ•°çš„åŸºç¡€ä¸Šï¼Œå¯ä»¥å½¢æˆä¸€ç§æ€ç»´æ–¹å¼

- å‡½æ•°å¯ä»¥å»ºæ¨¡ **â€œå˜æ¢â€** å’Œ **â€œå› æœå…³ç³»â€**

  - ä¿¡æ¯å¤„ç†é—®é¢˜ï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ç§ä¿¡æ¯çš„å˜æ¢é—®é¢˜

  - åœ¨é¢å‘ç‰¹å®šé¢†åŸŸé—®é¢˜çš„è½¯ä»¶åº”ç”¨ä¸­ï¼Œå¤§é‡æ¶‰åŠå¯¹ç‰©ç†ä¸–ç•Œä¸­å› æœå…³ç³»çš„ä»¿çœŸ

### 05 å‡ ä¸ªç®€å•çš„å‡½æ•°

- **é€»è¾‘é**å‡½æ•°

  ```haskell
  def not : ğ”¹ -> ğ”¹ = [b] match b {
      true => flse,
      flse => true,
  }
  ```

- **é€»è¾‘ä¸**å‡½æ•°

  ```haskell
  def and : (ğ”¹ âœ— ğ”¹) -> ğ”¹ = [p] match p {
      (true, true) => true,
      _            => flse,
  }
  ```

  å¦ä¸€ç§å®šä¹‰æ–¹å¼:

  ```haskell
  def and : ğ”¹ -> ğ”¹ -> ğ”¹ = [l] [r] match (l, r) {
      (true, true) => true,
      _            => flse,
  }
  ```

- ä¸ºäº†å®šä¹‰å…³äºè‡ªç„¶æ•°`â„•`çš„å‡½æ•°ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦ç»™å‡º`â„•`çš„å®šä¹‰

  ```haskell
  def â„• : Type = {
      ctor zero : Self
      ctor succ : Self -> Self
  }
  ```

  è¿™æ˜¯ä¸€ç§é€’å½’å®šä¹‰ï¼Œå…¶å«ä¹‰å¦‚ä¸‹ï¼š

  - `zero` æ˜¯ `â„•` ä¸­çš„ä¸€ä¸ªå…ƒç´ 

  - å¦‚æœ `n` æ˜¯ `â„•` ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆï¼Œ`succ n` ä¹Ÿæ˜¯`â„•` ä¸­çš„ä¸€ä¸ªå…ƒç´ 

  - `ctor` æ˜¯ä¸€ä¸ªå…³é”®å­— (Key Word)ï¼Œå…¶è‹±æ–‡å•è¯ â€œconstructorâ€ çš„ç¼©å†™

    - `ctor` åé¢çš„é‚£ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå…¬ç† (æ— éœ€ç»™å‡ºå…ƒç´ çš„å®šä¹‰)

      - æ‰€è°“å…¬ç†ï¼Œå°±æ˜¯ä¸€ä¸ªç¥ç§˜å­˜åœ¨

  > ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·å®šä¹‰è‡ªç„¶æ•°å‘¢ï¼Ÿ
  >
  > å› ä¸ºåœ¨è¿™ç§å®šä¹‰ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥åšå‡ºå¦‚ä¸‹è®¾å®šï¼š
  > - `0 === zero`
  > - `1 === succ(zero)`
  > - `2 === succ(succ(zero))`
  > - `3 === succ(succ(succ(zero)))`
  > <br> <br>

  > **å°å’Œå°šï¼š**
  > - è¿™ä¸å°±æ˜¯ä¸Šå¤ä¼ è¯´ä¸­çš„ **â€œç»“ç»³è®°æ•°â€** å—ï¼
  >
  > **å”åƒ§ï¼š**
  > - æ€ç»´çœŸæ•æ·ï¼›çœŸæ˜¯ä¸€ä¸ªå€¼å¾—æ•™è‚²çš„å¥½å­©å­ï¼
  >
  > **å°å’Œå°šï¼š**
  > - ä½†æ˜¯ï¼Œè¿™ä¹ˆ low çš„è‡ªç„¶æ•°å®šä¹‰ï¼ŒçœŸçš„é€‚åˆåœ¨åŒ—äº¬å¤§å­¦çš„è¯¾å ‚ä¸Šè®²å—ï¼Ÿ
  >
  > **å”åƒ§ï¼š**
  > - æˆ‘çŒœæµ‹ï¼Œä¹Ÿè®¸ä½ çš„æ€ç»´è¢«ä½ çš„é«˜ä¸­æ•°å­¦è€å¸ˆå›šç¦åœ¨æ•°å­¦å®‡å®™çš„ä¸€ç‰‡è’æ¼ ä¸­äº†
  >
  > - é‡‡ç”¨ç±»ä¼¼çš„æ–¹å¼ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹`ğ”¹`ç»™å‡ºå½¢å¼åŒ–çš„å®šä¹‰
  >   ```haskell
  >   def ğ”¹ : Type = {
  >       ctor flse : Self,
  >       ctor true : Self,
  >   }
  >   ```



- è‡ªç„¶æ•°çš„**åŠ æ³•è¿ç®—**

  ```haskell
  def plus : â„• -> (â„• -> â„•) = [a] [b] match (a, b) {
      (m, zero)    => m,
      (m, succ(n)) => succ(plus(m)(n))
  }
  ```

  åŠ æ³•è¿ç®—ç¤ºä¾‹ï¼š

  ```haskell
      plus(3)(4)  -- å› ä¸ºå®åœ¨å—ä¸äº†â€œç»“ç»³è®°æ•°â€çš„è‡ªç„¶æ•°ï¼Œæ‰€ä»¥å±€éƒ¨å›å½’äººç±»ä¸–ä¿—æ–‡æ˜ğŸ˜…
  === plus(3)(succ(3))
  === succ(plus(3)(3))
  === succ(plus(3)(succ(2)))
  === succ(succ(plus(3)(2)))
  === succ(succ(plus(3)(succ 1)))
  === succ(succ(succ(plus(3)(1))))
  === succ(succ(succ(plus(3)(succ 0))))
  === succ(succ(succ(succ(plus(3)(0)))))
  === succ(succ(succ(succ(3))))
  === (succ * succ * succ * succ)(3)
  ```

  > ä¸è¦è¢«ä¸Šé¢è¿™ç§çœ‹ä¼¼å¤æ‚çš„å®šä¹‰æ‰€å›°æ‰°ã€‚
  >
  > å®ƒåªä¸è¿‡ç”¨é€’å½’çš„æ–¹å¼å®šä¹‰äº†ä¸€ä»¶å¾ˆç®€å•çš„äº‹æƒ…ï¼š
  >
  > ```haskell
  >   plus(m)(n) === (succ * succ * succ * ... * succ)(m)
  >                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >                     "the composition of n succ"
  > ```

- è‡ªç„¶æ•°çš„**ä¹˜æ³•è¿ç®—**

  ```haskell
  def mult : â„• -> (â„• -> â„•) = [a] [b] match (a, b) {
      (m, zero)    => zero,
      (m, succ(n)) => plus(m)(mult(m)(n))
  }
  ```

  ä¹˜æ³•è¿ç®—ç¤ºä¾‹ï¼š

  ```haskell
      mult(3)(4)
  === mult(3)(succ 3)
  === plus(3)(mult(3)(3))
  === plus(3)(mult(3)(succ 2))
  === plus(3)(plus(3)(mult(3)(2)))
  === plus(3)(plus(3)(mult(3)(succ 1)))
  === plus(3)(plus(3)(plus(3)(mult(3)(1))))
  === plus(3)(plus(3)(plus(3)(mult(3)(succ 0))))
  === plus(3)(plus(3)(plus(3)(plus(3)(mult(3)(0)))))
  === plus(3)(plus(3)(plus(3)(plus(3)(0))))
  === (plus(3) * plus(3) * plus(3) * plus(3))(0)
  ```

  > ä¸è¦è¢«ä¸Šé¢è¿™ç§çœ‹ä¼¼å¤æ‚çš„å®šä¹‰æ‰€å›°æ‰°ã€‚
  >
  > å®ƒåªä¸è¿‡ç”¨é€’å½’çš„æ–¹å¼å®šä¹‰äº†ä¸€ä»¶å¾ˆç®€å•çš„äº‹æƒ…ï¼š
  >
  > ```haskell
  >   mult(m)(n) === (plus(m) * plus(m) * ... * plus(m))(zero)
  >                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >                    "the composition of n plus(m)"
  > ```

- è‡ªç„¶æ•°çš„**æŒ‡æ•°è¿ç®—**

  ```haskell
  def expn : â„• -> (â„• -> â„•) = [a] [b] match (a, b) {
      (m, zero)    => succ(zero),
      (m, succ(n)) => mult(m)(expn(m)(n))
  }
  ```

  æŒ‡æ•°è¿ç®—ç¤ºä¾‹ï¼š

  ```haskell
      expn(3)(4)
  === expn(3)(succ 3)
  === mult(3)(expn(3)(3))
  === mult(3)(expn(3)(succ 2))
  === mult(3)(mult(3)(expn(3)(2)))
  === mult(3)(mult(3)(expn(3)(succ 1)))
  === mult(3)(mult(3)(mult(3)(expn(3)(1))))
  === mult(3)(mult(3)(mult(3)(expn(3)(succ 0))))
  === mult(3)(mult(3)(mult(3)(mult(3)(expn(3)(0)))))
  === mult(3)(mult(3)(mult(3)(mult(3)(1))))
  === (mult(3) * mult(3) * mult(3) * mult(3))(1)
  ```

  > ä¸è¦è¢«ä¸Šé¢è¿™ç§çœ‹ä¼¼å¤æ‚çš„å®šä¹‰æ‰€å›°æ‰°ã€‚
  >
  > å®ƒåªä¸è¿‡ç”¨é€’å½’çš„æ–¹å¼å®šä¹‰äº†ä¸€ä»¶å¾ˆç®€å•çš„äº‹æƒ…ï¼š
  >
  > ```haskell
  >   expn(m)(n) === (mult(m) * mult(m) * ... * mult(m))(succ(zero))
  >                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >                    "the composition of n mult(m)"
  > ```

  > **å°å’Œå°šï¼š**
  > - æ€»æ˜¯nä¸ªç›¸åŒå‡½æ•°çš„ç»„åˆï¼›èƒ½ä¸èƒ½æœ‰äº›æ–°ä¸œè¥¿å‘¢ï¼Ÿ
  >
  > **å”åƒ§ï¼š**
  > - ä½•å¿…è®©è‡ªå·±è¿™ä¹ˆç´¯ï¼›è¿™æ ·åˆ’æ°´ä¸æŒºå¥½å˜›ï¼
  > <br> <br>

- **é˜¶ä¹˜è¿ç®—**

  ```haskell
  def fact : â„• -> â„• = [m] match m {
      zero    => succ(zero),
      succ(n) => mult(succ(n))(fact(n)),
  }
  ```

  > ä¸è¦è¢«ä¸Šé¢è¿™ç§çœ‹ä¼¼å¤æ‚çš„å®šä¹‰æ‰€å›°æ‰°
  >
  > å®ƒåªä¸è¿‡ç”¨é€’å½’çš„æ–¹å¼å®šä¹‰äº†ä¸€ä»¶å¾ˆç®€å•çš„äº‹æƒ…ï¼š
  >
  > ```haskell
  > fact(m) === (mult(m) * mult(m - 1) * ... * mult(1))(1)
  >             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >                  "the composition of n mult(_)"
  > ```

  > **å”åƒ§ï¼š** çœ‹ï¼Œæ˜¯ä¸æ˜¯æœ‰é‚£ä¹ˆä¸€ç‚¹ç‚¹æ–°ä¸œè¥¿äº† ğŸ˜…

- **æ–æ³¢é‚£å¥‘å‡½æ•°**

  ```haskell
  def fib : â„• -> â„• = [m] match m {
      zero          => zero,
      succ(zero)    => succ(zero),
      succ(succ(n)) => plus(fib(n))(fib(succ n)),
  }
  ```

  æ–æ³¢é‚£å¥‘å‡½æ•°è¿ç®—ç¤ºä¾‹ï¼š
  ```haskell
      fib(5)
  === plus(fib(3))(fib(4))
  === plus(plus(fib(1))(fib(2)))(plus(fib(2))(fib(3)))
  === plus(plus(1)(plus(fib(0))(fib(1))))(plus(plus(fib(0))(fib(1)))(plus(fib(1))(fib(2))))
  === plus(plus(1)(plus(0)(1)))(plus(plus(0)(1))(plus(1)(plus(fib(0))(fib(1)))))
  === plus(plus(1)(plus(0)(1)))(plus(plus(0)(1))(plus(1)(plus(0)(1))))
  ```

  > **å°å’Œå°šï¼š** è¿™ä¸‹å¥½äº†ï¼Œæ²¡æœ‰è§„å¾‹äº†ã€‚çœ‹ä½ æ€ä¹ˆåœ†è¿‡æ¥ ğŸ˜œ

### 06 è‡ªç„¶æ•°ä¸Šçš„ fold å‡½æ•°

- `plus` `mult` `expn` è¿™ä¸‰ä¸ªå‡½æ•°ä¹‹é—´å­˜åœ¨å…±æ€§

- è¿™ç§å…±æ€§å¯ä»¥è¢«å°è£…åœ¨ä¸€ä¸ªå‡½æ•°ä¸­

  ```haskell
  [T : Type]
  def fold
  : (T -> T) -> (T -> (â„• -> T))
  = [h : T -> T] [c : T] [m : â„•] match m {
      zero   => c,
      succ n => h(fold(h)(c)(n))
    }
    ------ å¼•å…¥ä¸€ç‚¹è¯­æ³•ç³– ------
  = [h : T -> T, c : T, m : â„•] match m {
      zero   => c,
      succ n => h(fold(h)(c)(n))
    }
  ```

- ç»™å®š `h : T -> T`, `c : T`ï¼Œä»¤ `f === fold(h)(c)`ï¼Œåˆ™å¯çŸ¥ï¼š
  - `f(zero) === c`

  - `f(succ n) === h(f(n))`

- å¦‚æœä¸ç†è§£è¿™ä¸ªå®šä¹‰çš„å«ä¹‰ï¼Œè¯·çœ‹å¦‚ä¸‹è§£é‡Šï¼š

  >
  > ç»™å®šä¸€ä¸ªè‡ªç„¶æ•° `n`ï¼Œå¯çŸ¥ï¼š
  >
  > ```haskell
  >    n === (succ * succ * succ * ... * succ)(zero)
  >          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >             "the composition of n succ"
  > ```

  > å·²çŸ¥ `f === fold(h)(c)`ï¼Œåˆ™å¯çŸ¥ï¼š
  >
  > ```haskell
  > f(n) === ( h   *   h   *  h  *  ... *  h )(c)
  >          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >             "the composition of n h"
  > ```

  > ä¹Ÿå³ï¼š
  > - `f(n)` æŠŠ `n` ä¸­çš„ `zero` æ›¿æ¢ä¸º `c`ï¼ŒæŠŠæ¯ä¸€ä¸ª `succ` æ›¿æ¢ä¸º `h`
  >
  > - `n` å’Œ `f(n)` æ˜¯åŒæ„çš„ï¼Œå³ï¼šä¸¤è€…å…·æœ‰ç›¸åŒçš„ç»“æ„
  >

- ä½¿ç”¨ `fold` å‡½æ•°ï¼Œå¯ä»¥å¯¹ `plus` `mult` `expn` è¿™ä¸‰ä¸ªå‡½æ•°è¿›è¡Œæ›´æ·±åˆ»çš„å®šä¹‰

  ```haskell
  def plus : â„• -> (â„• -> â„•) = [m] fold(succ)(m)

  def mult : â„• -> (â„• -> â„•) = [m] fold(plus(m))(zero)

  def expn : â„• -> (â„• -> â„•) = [m] fold(mult(m))(succ(zero))
  ```

  ç¤ºä¾‹ï¼š
  ```haskell
                 ----the composition of n succ -----
    n        === (succ    * succ    * ... * succ   )(zero)
    |              |         |         |     |
  plus(m)(n) === (succ    * succ    * ... * succ   )(m)
    |              |         |         |     |
  mult(m)(n) === (plus(m) * plus(m) * ... * plus(m))(zero)
    |              |         |         |     |
  expn(m)(n) === (mult(m) * mult(m) * ... * mult(m))(succ(zero))

  ```

- ä½¿ç”¨`fold`å‡½æ•°ï¼Œä¹Ÿå¯ä»¥å¯¹ `fact` `fib` è¿™ä¸¤ä¸ªå‡½æ•°è¿›è¡Œæ›´æ·±åˆ»çš„å®šä¹‰

  é¦–å…ˆå¼•å…¥ä¸¤ä¸ªè¾…åŠ©å‡½æ•°ï¼š

  ```haskell
  [A B : Type]
  def fst : A âœ— B -> A = [(a, b)] a

  [A B : Type]
  def snd : A âœ— B -> B = [(a, b)] b
  ```

  `fact`å‡½æ•°çš„å®šä¹‰ï¼š

  ```haskell
  def fact : â„• -> â„• = {
      def f
      : â„• âœ— â„• -> â„• âœ— â„•
      = [(m, n)] (m + 1, (m + 1) * n);

      ret snd * (fold(f)(0, 1));
  }
  ```

  ```haskell
                   ----the composition of n succ ----
    n     ===      ( succ  *  succ  *  ...  *  succ )(0)
    |                 |        |        |       |     |
  fact(n) === snd( (  f    *   f    *  ...  *   f   )(0, 1) )
  ```

  `fib`å‡½æ•°çš„å®šä¹‰ï¼š

  ```haskell
  def fib : â„• -> â„• = {
      def g
      : â„• âœ— â„• -> â„• âœ— â„•
      = [(m, n)] (n, m + n);

      ret fst * (fold(g)(0, 1));
  }
  ```

  ```haskell
                   ----the composition of n succ ----
    n     ===      ( succ  *  succ  *  ...  *  succ )(0)
    |                 |        |        |       |     |
  fib(n)  === fst( (  g    *   g    *  ...  *   g   )(0, 1) )
  ```

### 07 List ç±»å‹

- åœ¨ä¿¡æ¯å¤„ç†é—®é¢˜ä¸­ï¼Œç»å¸¸æ¶‰åŠä¸€ç»„æŒ‰ç…§æŸç§é¡ºåºæ’åˆ—çš„æ•°æ®ï¼›

  æˆ‘ä»¬å°†è¿™ç±»æ•°æ®ç”¨ List ç±»å‹è¿›è¡Œè¡¨ç¤ºã€‚

  - ä¾‹å¦‚ï¼šå¯¹äºæ’åºé—®é¢˜

    - å¾…æ’åºçš„æ•°æ®é€šå¸¸é‡‡ç”¨ List çš„æ–¹å¼è¿›è¡Œè¾“å…¥

    - æ’åºçš„ç»“æœè‡ªç„¶ä¹Ÿä»¥ List çš„æ–¹å¼è¿”å›

- List ç±»å‹çš„å®šä¹‰

  ```haskell
  def List : Type -> Type = [A] {
      ctor nil  : Self,
      ctor (+>) : A -> Self -> Self,
  }
  ```

- List ç±»å‹çš„ç¤ºä¾‹

   - `List(â„•)`ï¼šè‡ªç„¶æ•°åºåˆ—ç±»å‹

   - `nil`ï¼šä¸€ä¸ªä¸åŒ…å«ä»»ä½•å…ƒç´ çš„ç©ºåºåˆ—

   - `1 +> nil`ï¼šä»…åŒ…å« 1 ä¸ªå…ƒç´  `1` çš„è‡ªç„¶æ•°åºåˆ—

   - `1 +> (2 +> (3 +> (4 +> nil)))`ï¼šåŒ…å« 4 ä¸ªå…ƒç´  `1` `2` `3` `4` çš„è‡ªç„¶æ•°åºåˆ—

- List ç±»å‹ç›¸å…³çš„å‡½æ•°

  æ·»åŠ å…ƒç´ å‡½æ•°ï¼š

  ```haskell
  [T : Type]
  def cons
  : T -> (List(T) -> List(T))
  = [x, xs] x +> xs

  -- è¿™ä¸ªå‡½æ•°å°±æ˜¯æŠŠè¿ç®—ç¬¦ +> è¿›è¡Œäº†å‡½æ•°åŒ–
  ```

  é•¿åº¦å‡½æ•°ï¼š

  ```haskell
  [T : Type]
  def len
  : List(T) -> â„•
  = [xs] match xs {
      nil     => 0,
      a +> yx => 1 + len(yx)
  }
  ```

  é€†åºå‡½æ•°ï¼š

  ```haskell
  [T : Type]
  def rev
  : List(T) -> List(T)
  = {
      def rev-memo
      : List(T) -> (List(T) -> List(T))
      = [xs, ys] match ys {
          nil     => xs,
          m +> ms => rev-memo(m +> xs)(ms),
      };

      ret rev-memo(nil);
  }
  ```

  åºåˆ—æ‹¼æ¥å‡½æ•°ï¼š

  ```haskell
  [T : Type]
  def concat
  : List(T) -> (List(T) -> List(T))
  = [xs, ys] match xs {
      nil     => ys,
      m +> ms => m +> (concat(ms)(ys)),
  }
  ```

  è¿‡æ»¤å‡½æ•°ï¼š

  ```haskell
  [T : Type]
  def filter
  : (T -> ğ”¹) -> (List(T) -> List(T))
  = [f, xs] match xs {
      nil     => nil,
      m +> ms => match f(m) {
          true => m +> filter(f)(ms),
          flse =>      filter(f)(ms),
      }
  }
  ```

### 08 List ä¸Šçš„ fold å‡½æ•°

- å¦‚æœæˆ‘çš„ç†è§£æ²¡æœ‰é”™è¯¯ï¼Œåœ¨ä»»ä½•ç±»å‹ä¸Šéƒ½å­˜åœ¨ fold å‡½æ•°

  <div class="warning">

      è¿™ä¸ªè§‚ç‚¹å¾…ç¡®è®¤ã€‚
      æ•°å­¦ä¸Šçš„äº‹æƒ…ï¼Œåªè¦æ²¡æœ‰ç»™å‡ºè¯æ˜ï¼Œéƒ½ä¸èƒ½éšæ„ç›¸ä¿¡ã€‚
  </div>

- æ— è®ºå¦‚ä½•ï¼Œ`List` ç±»å‹ä¸Šå­˜åœ¨ fold å‡½æ•°ï¼Œè€Œä¸”å­˜åœ¨ä¸¤ä¸ªã€‚

  æˆ‘ä»¬å°†è¿™ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«å‘½åä¸º `foldl` å’Œ `foldr`ã€‚
  - å…¶ä¸­çš„åç¼€ `l` å’Œ `r` åˆ†åˆ«è¡¨ç¤º `left` å’Œ `right`

- `foldr` å‡½æ•°

  ```haskell
  [A B : Type]
  def foldr
  : (A -> (B -> B)) -> (B -> (List(A) -> B))
  = [h : A -> (B -> B), b : B, xs : List(A)] match xs {
      nil     => b,
      a +> ys => h(a)(foldr(h)(b)(ys))
  }
  ```

  > å¦‚æœä¸ç†è§£è¿™ä¸ªå®šä¹‰ï¼Œè¯·çœ‹å¦‚ä¸‹è§£é‡Šï¼š
  >
  > - ç»™å®š `xs : List(A)`ï¼Œä¸å¤±ä¸€èˆ¬æ€§ï¼Œä»¤ï¼š
  >
  >   ```haskell
  >   xs    === xn  +>  xn-1  +>  ...  +>  x1  +>  nil
  >   ```
  >
  >   åˆ™å¯çŸ¥ï¼š
  >
  >   ```haskell
  >   xs    === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
  >   ```
  >
  > - å·²çŸ¥ `f === foldr(h)(b)`ï¼Œåˆ™å¯çŸ¥ï¼š
  >
  >   ```haskell
  >   f(xs) === (    h(xn) *    h(xn-1) * ... *    h(x1) )(b)
  >   ```
  > - ä¹Ÿå³ï¼š
  >   - `f(xs)`æŠŠ`xs`ä¸­çš„`nil`æ›¿æ¢ä¸º`b`ï¼ŒæŠŠ`xs`ä¸­çš„æ¯ä¸€ä¸ª`cons`æ›¿æ¢ä¸º`h`
  >
  >   - `xs` å’Œ `f(xs)` æ˜¯åŒæ„çš„ï¼Œå³ï¼šä¸¤è€…å…·æœ‰ç›¸åŒçš„ç»“æ„

- `foldl` å‡½æ•°

  ```haskell
  [A B : Type]
  def foldl
  : (B -> (A -> B)) -> (B -> (List(A) -> B))
  = [h : B -> (A -> B), b : B, xs : List(A)] match xs {
      nil     => b,
      a +> ys => foldl(h)(h(b)(a))(ys),
  }
  ```

  > å¦‚æœä¸ç†è§£è¿™ä¸ªå®šä¹‰ï¼Œè¯·çœ‹å¦‚ä¸‹è§£é‡Šï¼š
  >
  > - å¼•å…¥ä¸€ä¸ªå·¥å…·å‡½æ•°
  >
  >   ```haskell
  >   [A B C : Type]
  >   def flip
  >   : (A -> (B -> C)) -> (B -> (A -> C))
  >   = [f, b, a] f a b
  >   ```
  >
  > - ç»™å®š `xs : List(A)`ï¼Œä¸å¤±ä¸€èˆ¬æ€§ï¼Œä»¤ï¼š
  >
  >   ```haskell
  >   xs    === xn  +>  xn-1  +>  ...  +>  x1  +>  nil
  >   ```
  >
  >   åˆ™å¯çŸ¥ï¼š
  >
  >   ```haskell
  >   xs    === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
  >   ```
  >
  > - å·²çŸ¥ `f === foldr(h)(b)`ï¼Œä»¤ `h' = flip(h)`ï¼Œåˆ™å¯çŸ¥ï¼š
  >
  >   ```haskell
  >   f(xs) === (   h'(x1) *   h'(x2)   * ... *   h'(xn) )(b)
  >   ```
  > - ä¹Ÿå³ï¼š
  >   - `f(xs)`æŠŠ`xs`ä¸­çš„`nil`æ›¿æ¢ä¸º`b`ï¼ŒæŠŠ`xs`ä¸­çš„æ¯ä¸€ä¸ª`cons`æ›¿æ¢ä¸º`h'`
  >
  >   - åŒæ—¶ï¼Œè¿˜é¡ºå¸¦é€†åºäº†ä¸€ä¸‹
  >
  > - ä½†å®é™…ä¸Šï¼Œ**å¹¶ä¸å­˜åœ¨ä¸€ä¸ªæ˜¾å¼çš„é€†åºç¯èŠ‚**ï¼›æ›´çœŸå®çš„è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹
  >
  >   ```haskell
  >   f(xs) === b â‰º xn â‰º xn-1 â‰º ... â‰º x1 â‰º nil
  >   ```
  >   å…¶ä¸­ï¼šè¿ç®—ç¬¦ `â‰º` å…·æœ‰å·¦ç»“åˆæ€§ï¼Œä¸” `b â‰º a === h(b)(a)`

### 09 ä½¿ç”¨foldå‡½æ•°ï¼Œé‡å®šä¹‰Listç›¸å…³çš„å‡½æ•°

- `len` å‡½æ•°

  ```haskell
  [A : Type]
  def len
  : List(A) -> â„•
  = {
      def h
      : A -> â„• -> â„•
      = [_, n] n + 1;

      ret foldr(h)(0)
  }
  ```

  > ```haskell
  >     xs  === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
  > len(xs) === (    h(xn) *    h(xn-1) * ... *    h(x1) )(0)
  > ```

- `rev` å‡½æ•°

  ```haskell
  [A : Type]
  def rev
  : List(A) -> List(A)
  = foldl(flip(cons))(nil)
  ```

- `concat` å‡½æ•°

  ```haskell
  [A : Type]
  def concat
  : List(A) -> (List(A) -> List(A))
  = [xs, ys] foldr(cons)(ys)(xs)
  ```

- `filter` å‡½æ•°

  ```haskell
  [A : Type]
  def filter
  : (A -> ğ”¹) -> (List(A) -> List(A))
  = [f] {
      def h
      : (A -> ğ”¹) -> (A -> (List(A) -> List(A)))
      = [f, a, xs] match f(a) {
          true => a +> xs,
          flse => xs,
      }

      ret foldr(h(f))(nil);
  }
  ```

  > ```haskell
  >           xs  === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
  > filter(f)(xs) === ( h(f)(xn) * h(f)(xn-1) * ... * h(f)(x1) )(nil)
  > ```

### 10 ä¸€ç§æ’åºç®—æ³•

- å¿«é€Ÿæ’åºç®—æ³•

  ```haskell
  def qsort
  : List(â„•) -> List(â„•)
  = [xs] match {
      nil     => nil,
      n +> ns => {
         def left = qsort(filter([m] m <  n)(ns));
         def rigt = qsort(filter([m] m >= n)(ns));

         ret concat(left)(n +> rigt);
      }
  }
  ```

  > **å°å’Œå°šï¼š**
  >
  > - è¿™æ®µä»£ç çœ‹èµ·æ¥è¿˜ä¸é”™ ğŸ‘
  >
  > **å”åƒ§ï¼š**
  >
  > - ä½ çš„å®¡ç¾èƒ½åŠ›çœ‹èµ·æ¥ä¹Ÿä¸é”™ ğŸ‘
  >
  > - å¯ä»¥è®©ä½ çœ‹ä¸€ä¸‹å»å¹´çš„å½¢å¼ï¼š
  >   ```haskell
  >   qsort : List(â„•) -> List(â„•)
  >   qsort(nil) = nil
  >   qsort(n +> ns) = concat(concat(qsort(filter(lt(n))(ns)))([n]))(qsort(filter(ge(n))(ns)))
  >   where
  >       lt : â„• -> (â„• -> ğ”¹)
  >       lt(n)(m) = if m < n then true else flse
  >
  >       ge : â„• -> (â„• -> ğ”¹)
  >       ge(n)(m) = not(lt(n)(m))
  >   ```
  > **å°å’Œå°šï¼š**
  >
  > - å¦‚æœè¿™å°±æ˜¯ç”¨ FP ä¹¦å†™çš„ç®—æ³•ï¼Œæ­¤ç”Ÿç»ä¸å­¦ FPï¼
  >
  > **å”åƒ§ï¼š**
  >
  > - å¥½å­©å­ï¼Œå¦‚æœç»™ä½ ä¸‰ç”Ÿä¸‰ä¸–çš„è´¢å¯Œï¼Œå­¦å¦ï¼Ÿ
  >
  > **å°å’Œå°šï¼š**
  >
  > - ä½›å­¦å·¥ä½œè€…å¯æ˜¯ä¸èƒ½æ’’è°çš„å“¦ï¼ï¼ï¼
  > <br> <br>

- **å†…å®¹** ä¸ **å½¢å¼**

  - è¿™æ˜¯ä¸€ä¸ªå…³äº â€œå†…å®¹â€ ä¸ â€œå½¢å¼â€ ä¸¤è€…ä¹‹é—´å…³ç³»çš„é—®é¢˜

    - å†…å®¹ï¼šå¯¹è‡ªç„¶æ•°åºåˆ—è¿›è¡Œæ’åºçš„ä¸€ç§æ–¹æ³•

    - å½¢å¼ï¼šè¡¨ç°è¿™ç§æ’åºæ–¹æ³•çš„å½¢å¼

  - è¿›ä¸€æ­¥è€Œè¨€ï¼Œå»å¹´çš„ç¨‹åºå­˜åœ¨çš„é—®é¢˜å¯ä»¥è¡¨è¿°ä¸ºï¼š

    - â€œå½¢å¼â€ å°äº â€œå†…å®¹â€: å†…å®¹æ˜¯å¾ˆå¥½çš„ï¼Œä½†å½¢å¼å®åœ¨æ˜¯å¤ªç³Ÿç³•äº†

  - å¦‚æœä½ èƒ½ä½“ä¼šåˆ°è¿™ä¸€ç‚¹ï¼Œä½ ä¼šå‘ç°ï¼šè¿™ä¸ªé—®é¢˜çš„ä¸¥é‡ç¨‹åº¦å¹¶ä¸åƒè¡¨é¢ä¸Šçœ‹èµ·æ¥çš„é‚£æ ·

  - ä¸ºä»€ä¹ˆè¿™ä¹ˆè¯´å‘¢ï¼Ÿå› ä¸ºï¼Œæœ¬è´¨ï¼ˆå†…å®¹ï¼‰æ¯•ç«Ÿè¿˜æ˜¯å¾ˆå¥½çš„

- **é‡èµ°é•¿å¾è·¯**

  - åœ¨æŸç§æ„ä¹‰ä¸Šï¼Œæˆ‘ä»¬æ­£åœ¨â€œé‡èµ°é•¿å¾è·¯â€

  - åœ¨å¾ˆå¤šå¹´ä»¥å‰ï¼Œç§‘ç ”å·¥ä½œè€…ä»¬å°±å·²ç»æ„è¯†åˆ°äº†è¿™ä¸ªé—®é¢˜
    - å³ï¼šå‡½æ•°å¼æ€ç»´çš„ â€œå½¢å¼â€ å°äº â€œå†…å®¹â€

  - åœ¨è¿™ä¸ªé—®é¢˜çš„é©±ä½¿ä¸‹ï¼Œä»–/å¥¹ä»¬è®¾è®¡äº†å„ç§å„æ ·çš„å‡½æ•°å¼ç¨‹åºè®¾è®¡è¯­è¨€

  - æˆ‘ä»¬å³å°†ä»‹ç»çš„Haskellè¯­è¨€ï¼Œå°±æ˜¯è¿™äº›å‡½æ•°å¼ç¨‹åºè®¾è®¡è¯­è¨€çš„é›†å¤§æˆè€…

  - ä¸è¿‡ï¼Œç›®å‰çœ‹æ¥ï¼ŒHaskell è¯­è¨€æ­£åœ¨è€å»ï¼š**ä¸€é²¸è½ï¼Œä¸‡ç‰©ç”Ÿï¼**

    - ä¾‹å¦‚ï¼Œæœ¬ç« ä¸­ç¨‹åºçš„è¯­æ³•ï¼Œå°±æ˜¯åœ¨ Haskell è¯­è¨€çš„åŸºç¡€ä¸Šæ”¹è‰¯å½¢æˆçš„


### 11 å‰§é€ï¼šé‡‡ç”¨ Haskell è¯­è¨€ç¼–å†™çš„ qsort ç®—æ³•

```haskell
qsort :: Ord a => [a] -> [a]
qsort []     	= []
qsort (p:xs)	= qsort lt ++ [p] ++ qsort ge
  where
    lt = filter (<  p) xs
    ge = filter (>= p) xs
```

### æœ¬ç« ä½œä¸š

> <div class="warning">
>
>   æœ¬ç« æ²¡æœ‰ä½œä¸šã€‚
>
>   ä½†æ˜¯ï¼Œä½ éœ€è¦æƒ³æ¸…æ¥šï¼šè¿™é—¨è¯¾æ˜¯å¦é€‚åˆä½ ã€‚
> </div>
